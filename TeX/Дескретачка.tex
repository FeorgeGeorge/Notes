\documentclass{book}
%nerd stuff here
\pdfminorversion=7
\pdfsuppresswarningpagegroup=1
% Languages support
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
% Some fancy symbols
\usepackage{textcomp}
\usepackage{stmaryrd}
% Math packages
\usepackage{amsmath, amssymb, amsthm, amsfonts, mathrsfs, dsfont, mathtools}
\usepackage[bb=boondox]{mathalfa}
\usepackage{cancel}
% Bold math
\usepackage{bm}
% Resizing
%\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
% Optional font for not math-based subjects
%\usepackage{cmbright}

\author{Коченюк Анатолий}
\title{Дискретная математика }

\usepackage{url}
% Fancier tables and lists
\usepackage{booktabs}
\usepackage{enumitem}
% Don't indent paragraphs, leave some space between them
\usepackage{parskip}
% Hide page number when page is empty
\usepackage{emptypage}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{xcolor}
% Some shortcuts
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\R{\ensuremath{\mathbb{R}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}
\renewcommand\O{\ensuremath{\emptyset}}
\newcommand\Q{\ensuremath{\mathbb{Q}}}
\renewcommand\C{\ensuremath{\mathbb{C}}}
\newcommand{\p}[1]{#1^{\prime}}
\newcommand{\pp}[1]{#1^{\prime\prime}}
% Easily typeset systems of equations (French package) [like cases, but it aligns everything]
\usepackage{systeme}
\usepackage{lipsum}
% limits are put below (optional for int)
\let\svlim\lim\def\lim{\svlim\limits}
%\let\svlim\int\def\int{\svlim\limits}
% Command for short corrections
% Usage: 1+1=\correct{3}{2}
\definecolor{correct}{HTML}{009900}
\newcommand\correct[2]{\ensuremath{\:}{\color{red}{#1}}\ensuremath{\to }{\color{correct}{#2}}\ensuremath{\:}}
\newcommand\green[1]{{\color{correct}{#1}}}
% Hide parts
\newcommand\hide[1]{}
% si unitx
\usepackage{siunitx}
\sisetup{locale = FR}
% Environments
% For box around Definition, Theorem, \ldots
\usepackage{mdframed}
\mdfsetup{skipabove=1em,skipbelow=0em}
\theoremstyle{definition}
\newmdtheoremenv[nobreak=true]{definition}{Определение}
\newmdtheoremenv[nobreak=true]{theorem}{Теорема}
\newmdtheoremenv[nobreak=true]{lemma}{Лемма}
\newmdtheoremenv[nobreak=true]{problem}{Задача}
\newmdtheoremenv[nobreak=true]{property}{Свойство}
\newmdtheoremenv[nobreak=true]{statement}{Утверждение}
\newmdtheoremenv[nobreak=true]{corollary}{Следствие}
\newtheorem*{note}{Замечание}
\newtheorem*{example}{Пример}
\renewcommand\qedsymbol{$\blacksquare$}
% Fix some spacing
% http://tex.stackexchange.com/questions/22119/how-can-i-change-the-spacing-before-theorems-with-amsthm
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\usepackage{xifthen}
\def\testdateparts#1{\dateparts#1\relax}
\def\dateparts#1 #2 #3 #4 #5\relax{
    \marginpar{\small\textsf{\mbox{#1 #2 #3 #5}}}
}

\def\@lecture{}%
\newcommand{\lecture}[3]{
    \ifthenelse{\isempty{#3}}{%
        \def\@lecture{Lecture #1}%
    }{%
        \def\@lecture{Lecture #1: #3}%
    }%
    \subsection*{\@lecture}
    \marginpar{\small\textsf{\mbox{#2}}}
}
% Todonotes and inline notes in fancy boxes
\usepackage{todonotes}
\usepackage{tcolorbox}

% Make boxes breakable
\tcbuselibrary{breakable}
\newenvironment{correction}{\begin{tcolorbox}[
    arc=0mm,
    colback=white,
    colframe=green!60!black,
    title=Correction,
    fonttitle=\sffamily,
    breakable
]}{\end{tcolorbox}}
% These are the fancy headers
\usepackage{fancyhdr}
\pagestyle{fancy}

% LE: left even
% RO: right odd
% CE, CO: center even, center odd
% My name for when I print my lecture notes to use for an open book exam.
% \fancyhead[LE,RO]{Gilles Castel}

\fancyhead[RO,LE]{\@lecture} % Right odd,  Left even
\fancyhead[RE,LO]{}          % Right even, Left odd

\fancyfoot[RO,LE]{\thepage}  % Right odd,something additional 1  Left even
\fancyfoot[RE,LO]{}          % Right even, Left odd
\fancyfoot[C]{\leftmark}     % Center

\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\usepackage{tikz}
\begin{document}
    \maketitle
    
    \section{Введение}
    Связаться:
    \begin{itemize}
        \item stankev@gmail.com Собирать культуру общения: указывать Фамилию, Имя
        \item Телеграм @andrewzta  (для немедленного ответа. Если нет, оно утонет).
        \item +79219034426 (для катастрофических ситуаций, ожидается, что звонить никто не будет) (ни в коем случае не писать смс)
    \end{itemize}

    Обращаться можно по методическим вопросам. Если проблема группы -- пишет староста.

    Не писать по учебно-методическим проблемам (общежитие, медосмотр, армия ..) для этого есть зам. декана Харченко (легко найти контакты в ису)

    Про отчётность будет на первой практике.

    Лекции есть в ютубе andrewzta
    \chapter{1 курс}
    \section{Фундамент}

        Множество -- неопределяемое понятие. Множество состоит из элементов. $a\in A$ а-маленькое принадлежит множеству А-большое

        $A = \{2, 3, 9\}$

        $A = \{n \mid n\text{ чётно}, n \in \N \}$ -- фильтр

        $A, B:$
        \begin{itemize}
            \item $A\cup B = \{a \mid a\in A \text{ или } a\in B\}$
            \item $A\cap B = \{a \mid a\in A \text{ и } a\in B\}$
            \item $A\setminus B = \{a | a\in A \text{ и } a\not\in B\}$
            \item $\overline{A} = \{a | a\not\in A\}$??? $U$ -- универсум

                $\overline{A} = U\setminus A$
            \item[] $A\setminus B = A\cap \overline{B}$
            \item $A \triangle B = A\oplus B = (A\cup  B)\setminus (A\cap B)$
        \end{itemize}



        \begin{note}
            Если множество -- любой набор чего-угодно, возникает парадокс Рассела.

            $A = \{a|a\text{ -- множество, } a\not\in a\}$
            
            Вопрос: лежит ли в себе $A$? 
        \end{note}

        \begin{definition}
            [Пара]

            $A, B$ -- множества. Мы можем рассмотреть множество пар, где первый элемент из $A$, а второй из $B$.

            $A \times B = \{(a,b) | a\in A, b\in B\}$

            $A\times A = A^2$
        \end{definition}

        $(A\times B)\times C = \{(x,y)|x\in A\times B, y\in C\} = \{((a,b),y) |a\in A, b\in B, y\in C\}$ 
   
        $A\times (B\times C) = \{(a,(y,z))| a\in A, y\in B, z\in C\}$
        
        $A\times B\times C = \{(a,b,c)|a\in A, b\in B, c\in C\}$

        Для простоты, здесь и далее эта операция будет считаться ассоциативной и первые две строчки будут давать то же, что третья -- множество троек.

        $A\times A\times A = A^3$
        $A^n = \begin{cases}
            A&,n=1\\
            A\times A^{n-1}&,n>1\\
        \end{cases}$

        $A^0 = \{[]\} = \{\varepsilon\}$ -- пустая последовательность.         
        \begin{example}
            $A = {2, 3, 9}$
->    
            $A\times A =\{(2,2),(2,3),(2,9),(3,2),(3,3),\ldots\}$ 
        \end{example}

        \begin{note}
            У множества есть элементы и для любого элемента из универсума, он либо входит (1 раз) либо не входит.
        \end{note}

        \begin{definition}
            Функция -- отображение, которое каждому элементу из одного множества ставит в соответветвие единственный элемент из другого множества

            $f:A\to B$ 

            График $\{(x,f(x))\}$.

            Формально будем отождествлять функцию и её график.

            $f\subset A\times B\quad \forall a\in A \exists ! b\in B\quad (a,b)\in f$
        \end{definition}

        \begin{note}
            Не путайте принадлежность и включение.

            $a\in A$

            $A, B, \forall a$ (если $a\in A$, то $a\in B$) $A\subset B$

            $D_4 = \{n|n\text{ кратно } 4\}$

            $E = \{n|n\text{ чётно}\}$

            $D_4\subset E$

            $\{2, 3, 9\} \subset  \{2, 3, 4, \ldots, 9\}$

            $A\subset A$

            $\O \subset A$

            $A\subset U$
        \end{note}

        \begin{note}
            Необязательно все $b$ попадают в график.
            
            $sqr:\N \to \N $ -- только квадраты чисел
        \end{note}

        \begin{definition}
            $\forall b\in B\exists a\in A: b = f(a)$ -- сюръекция
        \end{definition}

        \begin{definition}
            $\forall a\in A \forall b\in B\quad a\neq b \implies f(a)\neq f(b)$
        \end{definition}

        \begin{note}
            Принцип Дирихле -- нет инъекции из большего в меньшее множество. Если кроликов больше, чем клеток, то какому-то кролику не хватит клетки.
        \end{note}

        \begin{definition}
            Если $f$ -- инъекция и сюръекция, то $f$ -- называется биекцией.

            Если между двумя конечными множествами есть биекция, то у них равное количество элементов.
        \end{definition}

        \begin{definition}
            Два множества называется равномощными, если между ними есть биекция
        \end{definition}

        $B^A$ -- множество функций из $A$ в $B$.

        $|A| = a, |B| = b\quad |A\times B| = a\cdot b\quad |B^A| = b^a$

        $|A^{\O }| = 1$ эфемерная функция, которой ничего не передать.

        $\O ^A = \O , A \neq \O $

        $\O ^{\O } = 1$
       
        \begin{definition}
            $R\subset A\times B$ -- отношение (бинарное).

        \end{definition}
        \begin{example}
            $A=B=\N \quad R = \{(a,b)|a<b\}\quad R= <$

            $a\vdots b\quad 6\vdots 2\quad 6\not\vdots 5$

            $A$ = люди, $B$ = собаки, $R = \{(a,b)|a\text{ -- хозяин} b\}$
        \end{example}

        Рассмотрим 5 классов отношений на квадрате множества:
        \begin{enumerate}
            \item рефлексивные $\forall a \quad aRa$

                $RC(R)$ -- рефлексивное замыкание, включаем все пары $(a,a)$
            \item антирефлексивные $\forall a \quad \neg aRa$
            \item симметричные $aRb \implies bRa$
            \item антисимметричные $aRb, a\neq b \implies \neg bRa$

                или $aRb$ и $bRa \implies a=b$
            \item транзитивность $aRb, bRc \implies  aRc$
        \end{enumerate}
        
        \begin{definition}
            1+3+5 -- рефлексивные, симметричные и тразитивные -- называются отношениями эквивалентности. 
        \end{definition}
        \begin{theorem}
            $R$ -- отношение эквивалентности на $X$, то элементы $X$ можно разбить на классы эквивалентности так, что:

            $a$ и $b$  в одном классе $\implies  aRb$
            $a$ и $b$  в разных  классах $\implies \neg aRb$

            множество таких классов обозначается $X / R$

            $N / \equiv_3 = $
            \begin{align*}
                \{\{1,4,7,10,\ldots)\\
                        \{2,5,8,11,\ldots)\}\\
                        \{3,6,9,12,\ldots)\}\}\\
            .\end{align*}   
        \end{theorem}
        \begin{note}
            Отношение равномощности -- отношение эквивалентности.

            Классы эквивалентности -- порядки. Для конечного случая обозначаются числами
        \end{note}

        \begin{definition}
            1+4+5 -- рефлексивные, антисимметричные и транзитивные -- частичные порядки

            Множество, на котором введён частичный порядок, называется частично упорядоченным (ч.у.м -- частично упорядоченное множество, poset -- partially organised set).
        \end{definition}
        
        $R\subset X\times X$

   $X, Y, Z\quad R:X\times Y\quad S:Y\times Z$

   \begin{definition}
       Композиция отношений: 

       $T = R\circ S\quad xTy \iff \exists z: xRz \text{ и } zSy$

       т.е. есть $z$, через который можно пройти, чтобы попасть в $y$ из $x$.
   \end{definition}

    \begin{note}
        $R\subseteq X\times X\quad S\subseteq X\times X$

        $R\circ S \subseteq X\times X$
        
        $R\circ R\subseteq X\times X$ -- пройти два раза по стрелкам.

        $R^3 = R\circ R^2 = R^2\circ R$ -- пути длины ровно 3.

        $S\circ T\circ U$ -- идём по стрлке из $S$ в $T$, а потом в $U$
    \end{note}

    \begin{definition}
        Транзитивное замыкание.

        $R^+ = \bigcup\limits_{k=1}^{\infty } R^k$

        $R^0 = \{(x,x)|x\in X\}$ -- они не включаются по дефолту в $R^+$

        $R^* = \bigcup\limits_{k=0} ^{\infty } R^k = R^+ \cup R^0$ -- если между двумя вершинами существует какой-либо путь
    \end{definition}
    \begin{note}
        Транзитивное замыкание -- транзитивно.

        Пусть $xR^+y \implies x R^i y$

        Пусть $yR^+z \implies yR^j z$

        $\implies x(R^i\circ R^j)z \implies  xR^k z$
    \end{note}
    \begin{note}
        $\forall T:T$ -- транзитивно. $T\subset R \implies T^+ \subset R$
    \end{note}
    \begin{proof}
        По индукции:

        База: $R^1 \subset T$ -- дано

        Переход: $R^i\subset T \implies  R^{i+1}\subset T$

        $xR^{i+1}y \implies x(R\circ R^i)y\implies \exists z: xRz\&zR^iy \implies xTz\&zTy \implies xTy$ (по транзитивности $T$)
    \end{proof}

    \section{Булевы функции}

    $\O $ -- пустое множество. С функциями из/в него всё достаточно грустно.

    $\{unit\}$

    $void$ -- ничего, константная функция

    $\mathbb{B} = \{0,1\}$

    $f:A_1\times A_2\times \ldots\times A_n \to B$  -- функция от нескольких аргументов. Из одного, но декартового произведения

    Булева функция: $f:\mathbb{B}^n\to B$

    $n=0$ -- ноль аргументов $\mathbb{B}^0 = \{[]\}$

    $\mathbb{0}, \mathds{1}$
     
    $n=1\quad$
    \begin{table}[htpb]
        \centering
        \caption{n=1}
        \label{tab:n1}
        \begin{tabular}{c|cccc}
            x&$\mathbb{0}$&id&$\neg$&$\mathds{1}$\\\hline
        0 &0  &0  &1  &1\\
        1&0&1&0&1 \\
        \end{tabular}
    \end{table}
   \begin{note}
       Подобные таблицы называются таблицами истинности функций
   \end{note} 
    $n=2$
    \begin{table}[htpb]
        \centering
        \caption{n=2}
        \label{tab:n2}
        \begin{tabular}{cc|cccccccccccccccc}
            x&y  & $\mathbb{0}$ & $\land$   &$\not\to $  & $P_1$ & $\not\leftarrow$ & $P_2$ &$\oplus$ & $\vee$ & $\downarrow$ & = & $\neg P_2$ & $\leftarrow$ & $\neg P_1$ & $\to $ & $\uparrow$ & $\mathds{1}$ \\\hline
         0&  0&  0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 &1  &1  &1 \\
         0&  1&  0&  0& 0 & 0 &1  & 1 &  1&  1& 0 & 0 & 0 & 0 &1  & 1 & 1 & 1\\
         1&  0&  0&  0&  1&  1& 0 &0  & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 &1  &1 \\
         1&  1&  0&  1&  0&  1& 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1\\
        \end{tabular}
    \end{table}

    С помощью стрелки Пирса ($\downarrow$) и штриха Шеффера ($\uparrow$) можно выразить любую другую: $\neg x  = x \downarrow x$

    \section{Задания булевых функций}

    Самый простой способ -- таблица истинности.

    $\oplus_n$ -- $2^n$ значений. глупо их все отдельно описывать

    \begin{enumerate}
        \item Задание функции формулой.

            Определим базисные функции, систему связок.

            Например: $\land, \vee, \neg, \oplus$

            $x_1 \oplus x_2 \oplus x_3 \ldots $

            $\{f_1, f_2, .., f_n\}$ -- базисные.

            Строка -- формула. $f_i(x_1, \ldots, x_k)$ -- формула

            \begin{definition}
                Дерево разбора формулы. Если у функции арность -- $k$, то у ноды будет ровно $k$ сыновей
            \end{definition}
    \end{enumerate}

    $\overline{F}$ --  функции, которые записываются формулами, используя $F$ (замыкание $F$)

    \begin{theorem}
        [Теорема о стандартном базисе] $\overline{\{\land, \vee, \neg\}} = \mathbb{B}$
    \end{theorem}
    \begin{proof}
        Рассмотрим таблицу истинности функции $f$. Она принимает $n$ аргументов и в ней $2^n$ строк.

        Пусть $f\neq \mathbb{0}$. Рассмотрим строчки, в которых единицы.

        По аргументам запишем с не -- аргументы, которые 0, и без не -- те, которые 1

        $\neg x_1 \land \neg x_2 \land x_3 \land \neg x_4 \land x^5$ -- 1 на ровно одном наборе элементов. А теперь возьмём "или" по всем строкам, в которых $1$ 

        Одна такая строка называется термом. 

        Такая форма называется совершенной дизъюнктивной нормальная формой.
    \end{proof}
    \begin{lemma}
        Любая функция, кроме тождественного 0  -- есть СДНФ

        $x\vee \neg x$ -- тождественный ноль
    \end{lemma}

    Напоминание о способах задания функций:

    $F\quad x_1, x_2, \ldots ,x_{n} f\in F$

    $or(and(x, not(y)),or(0,z))$. Такие формы называются формулами. По формуле можно построить дерево разбора.

    $\land, \lor, \neg$ 

    СДНФ -- дизъюнкция термов, где каждый терм -- коньюнкция литералов. Совершенная --  в каждом терме есть все переменные по одному разу.

    \begin{lemma}
        $\sqsupset F$ -- некоторое множество. $\overline{F} = \mathbb{BF}$

        $\sqsupset G$ -- некоторое множество функций $\forall f\in F\quad f\in \overline{G}$

        Тогда с помощью $G$ можно выразить любую функцию $\overline{G} = \mathbb{BF}$
    \end{lemma}
    \begin{proof}
        $G\to F\to \forall  \implies G\to \forall $ -- то, что нужно доказать

        фиксируем функцию $h\in \mathbb{BF}$. Она каким-то деревом разбора выражается через функции $f\in F$. Каждая функция $f$ выражается через $g\in \overline{G}$, тогда подставим выражения функций $f$ через $g$  в узлах дерева и получим выражение функции $h$ через $\overline{G}$, значит любая функция выражается через $\overline{G} \implies \overline{G} = \mathbb{BF}$. 
    \end{proof}

    \begin{example}
        $\{\oplus, \land, \mathbb{1}\}$

        $x\land y = x\land y\qquad \neg x = x\oplus 1$ -- такая запись называется полиномом жегалкина

        $x\lor y = (x\land y)\oplus x\oplus y$
    \end{example}

    $x\land y = xy\oplus y\oplus x$ -- $\land$ опускают

    $(x\oplus y)(y\oplus z) = xy\oplus y\oplus xz\oplus yz$

    $(x\oplus 1)(y\oplus 1) = xy\oplus x\oplus y\oplus 1$

    $a\land a = a$ -- идемпотентность 

    \begin{theorem}
        Любая булева функция (кроме $\mathbb{0}$) имеет каноничный полином, причём единственный (с точностью до коммутативности и ассоциативности)
    \end{theorem}
    \begin{proof}
        булевых функций от $n$ аргументов -- $2^{2^n}$

        Мономов -- $2^n$. Каждый из них мы можем взять или не взять $\implies $ всего $2^{2^n}-1$, -1 из случая, где мы рассматриваем пустую сумму.

        Есть инъекция из булевых функций в полиному Жегалкина. Это инъеция между равномощными множествами $\implies $ это биекция.
    \end{proof}

    \section{Линейный функции}

    Полиному Жегалкина, в которых нету $\land$

    $x\oplus y\quad x\oplus y\oplus 1$

    \begin{definition}
        Функция называется линейной, если её канонический полином Жегалкина не сожержит $\land$
    \end{definition}

    \begin{statement}
        Если $F$ содержит только линейные функции, то и $\overline{F}$ содержит только линейные функции
    \end{statement}
    \begin{proof}
        $x_1\oplus x_2 \oplus x_3$

        $x_7\oplus x_8 = (x_1\oplus x_2\oplus x_3)\ldots$ Заменяем и получаем  всё ещё сумму переменных или $\mathbb{1}$

        Если формально, строим дерево, заменяем узлы на линейные фукнции, заменяем повторы, раскрываем скобки (пользуемся ассоциативностью $\oplus$) и получаем линейную функцию.
    \end{proof}

    \begin{statement}
        Если $F$ содержит только функции, сохраняющие $0$, то и $\overline{F}$ тоже

        аналогично для $1$
    \end{statement}

    \begin{definition}
        Функция $f$ называется монотонной $\iff $ для двух наборов $x_1, x_2, \ldots, x_{n} \quad y_1, y_2, \ldots, y_{n} $, что $x_i\leqslant y_i\qquad 0<1$

        \[
            f(x_1, x_2, \ldots, x_{n} ) \leqslant f(y_1,y_2,\ldots,y_{n} )
        .\] 
    \end{definition}

    \begin{statement}
        Из монотонных функций не выразить немонотонную.
    \end{statement}
    \begin{proof}
        Доказывается индукцией по дереву разбора. Увеличили аргументы, увеличился уровень выше, выше и корень тоже.
    \end{proof}

    \begin{definition}
        Функция $f$ называется самодвойственной, если

        $f(x_1, \ldots, x_{n} ) = \neg f(\neg x_1, \ldots, \neg x_{n} )$ 
    \end{definition}
        
    \begin{statement}
        Из самодвойственных функций тоже не выйти. Тоже деревом разбора.
    \end{statement}
    Классы Поста:
    \begin{enumerate}
        \item $F_0$ -- сохраняющие $0$
        \item $F_1$ -- сохраняющее $1$
        \item $F_l$ -- линейные
        \item $F_m$ -- монотонные
        \item $F_s$ -- самодвойственные
    \end{enumerate}

    \begin{lemma}
        $F\subseteq F_i, i\in\{0,1,l,m,s\} \implies \overline{F}\subseteq F_i$
    \end{lemma}
    \begin{corollary}
        $\overline{F}$ -- не полно
    \end{corollary}
    \begin{theorem}
        [критерий Поста] $F$ -- полное $\iff F \not\subseteq F_i$ для всех $i\in \{0,1,l,m,s\}$
    \end{theorem}
    \begin{proof}
        $\implies $ Если нет, то все функции лежат внутри этого класса. Не будет включена $\uparrow$ например, не лежащая ни в одном классе Поста.

        $\impliedby $ $f_0\not\in F_0, f_1 \not\in F_1, f_l \not\in F_l, f_m \not\in F_m, f_s \not\in F_s$

        $a(x) f_0\left(x, x, \ldots, x  \right) $

        $a\left(  0 \right) = 1$

        \begin{itemize}
            \item[a] $a(1) = 1 \implies a(x) = 1$
            \item[b] $a(1) = 0 \implies a(x) = \neg x$
        \end{itemize}
        $b(x) = f_1(x, x, \ldots, x)\quad b(1) = 0$
        \begin{enumerate}
            \item $b(1) = 0 \implies b(x) = \mathbb{0}$
            \item $b(1) = 1 \implies  b(x) = \neg x$
        \end{enumerate}

        \begin{itemize}
            \item [1a] $\mathbb{1~0}$
            \item [1b] $\mathbb{0}, \neg$
            \item [2a]  $\mathbb{1}, \neg$ 
            \item [2b] $\neg, x$
        \end{itemize}

        \begin{itemize}
            \item [1a] $\mathbb{1,0}\quad f_m(x_1, \ldots, x_{n} ) >f_m(y_1, \ldots, y_{n} )\quad x_i\leqslant y_i$ Значит первое -- 1, а второе -- 9

                $f_m(x_1, \ldots, x_{n} )\\f_m(y_1, \ldots, x_{n} )\\f_m(y_1, \ldots, x_{n} )\\ \vdots\\ f_m(y_1, \ldots, y_{n} )$

                В какой-то момент единица сменилась нулём на соседних строках

                $f(y_1, \ldots, y_{i-1}, x_i, \ldots, x_{n} )=1$

                $f(y_1, \ldots, y_{i-1}, y_i, \ldots, x_{n} )=0$

                $x_i\leqslant y_i\quad x_i\neq y_i \implies x_i = 0, y_i = 1$

                $c(z) = f_m(y_1, \ldots y_{i-1}, z, x_{i+1}, \ldots, x_{n} )$ здесь вместо x и y подставлены константы

                $c(z) = \neg z$
            \item [2b] $f_s\quad x_1, x_2, \ldots, x_{n} : f_s(x_1, x_2, \ldots, x_{n} ) = \neg f(\neg x_1, \ldots, \neg x_{n} ) = t$

                $d(z) = f_s(z^{x_1}, z^{x_2}, \ldots, z^{x_{n} })\quad x^y = \begin{cases}
                    x&, y=1\\
                    \neg x&, y= 0 \\
                \end{cases}$

                $d(0) = t, d(1) = t$

                $\begin{cases}
                    t=1 \implies d(t) = \mathbb{1}\\
                    t=0 \implies d(t) = \mathbb{0}
                \end{cases}$
        \end{itemize}
        Итак мы получили $\mathbb{1,0},\neg$

        Воспользуемся нелинейной функцией: $f_l$ среди нелинейных членов в полиноме Жегалкина выберем тот, в котором меньше всего переменных. Не умаляя общности скажем, что он выглядит как $xyu_1\dots u_k\quad k+2\geqslant 2$.

        $h(x,y) = f_l(x,y,\mathbb{1}, \mathbb{1}, \ldots, \mathbb{1}i, \mathbb{0}, \mathbb{0}, \ldots\mathbb{0})$ Вместо $u_k$ подставляем $\mathbb{1}$, а вместо остальных $\mathbb{0}$

        $h(x,y)= xy[\oplus x][\oplus y][\oplus \mathbb{1}]$ -- восемь вариантов.

        Если есть $\oplus 1$, напишем $\neg$

        $xy[\oplus x][\oplus y]$       

        $xy = x\land y$

        $xy\oplus x\oplus y = x\lor y$

        $xy\oplus x\quad h(x,\neg y) = x(y\oplus 1)\oplus x = xy$

        $xy\oplus y\quad h(\neg x, y) = (x\oplus 1)y\oplus y = xy$
    \end{proof}

\section{Преобразование Мёбиуса}
$f(x_1, x_2, \ldots, x_{n} ) = x\vee y / x / y / 1$    

$a_{xy}xy \oplus a_x x \oplus a_y y \oplus a_1$

$f(x_1, x_2, \ldots, x_{n} ) = \bigoplus\limits_{\vec s \in \mathbb{B}^n} a_s \prod\limits_{i:s(i) = 1} x_i = \bigoplus\limits_{\vec s\leqslant \vec x} a_{\vec s}$

$s(i) = 1 \implies  x(i) = 1 \iff  s\& x = s \iff s\leqslant x$ (покомпонентно)

\begin{definition}
    [Доминирование]

    $\vec a \leqslant  \vec b \iff  \forall i\quad a_i\leqslant b_i$
\end{definition}

Таблица истинности:
\begin{tabular}{cccc|c}
    0&0&0&\ldots&$f_{00\ldots0}$\\
    0& 0 & \ldots & 1& $f_{00\ldots_1}$\\
     &&&&\\
     &&&&\\
    1&1&\ldots&1&$f_{11\ldots_1}$\\
\end{tabular}

$f\in \mathbb{B}^{2^n}$

$\vec a = M\vec f\quad \vec f = M\vec a$

$M_{xs} = [s\leqslant x]$

Преобразование Мёбиуса -- матрица $M = \begin{pmatrix} 1&0&0&0\\1&1&0&0\\1&0&1&0\\1&1&1&1 \end{pmatrix}$



\begin{theorem}
    Преобразование матрицы --  инволюция ($M = M^{-1}$)

    $\vec a_t = \bigoplus\limits_{x\leqslant t} f_x $
\end{theorem}
\begin{proof}
    $\bigoplus\limits_{x\leqslant t}f_x = \bigoplus\limits_{x\leqslant t}\bigoplus\limits_{s\leqslant x} a_s = \bigoplus\limits_{s,x:s\leqslant x\leqslant t}a_s = \bigoplus\limits_S [(\#x: s\leqslant x\leqslant t)\%2]a_s = a_t$

    \begin{enumerate}
        \item $s\not\leqslant t \implies  \#x = 0$
        \item $s=t \implies  \#x = 1, s=x=t$
        \item $s\leqslant t_1\quad s\neq ts$ -- нечётное число раз ксорится. $z$ различных разрядов, $z\leqslant 1\quad 2^{z}$
    \end{enumerate}
\end{proof}

\begin{example}
    $  \begin{pmatrix}1\\1\\1\\0  \end{pmatrix} $
        $a_{11}=1, a_{01}=0, a_{10}=0, a_{00} = 1$

        $xy\oplus 1$ -- штрих Шефера
\end{example}

\section{Схемы из функциональных элементов (Boolean Circuts)}

\begin{definition}
    Топологической сортировкой называется отображение $\varphi:V \to  \{1, \ldots, n\}\quad u\neq v \implies  \varphi(u)\neq \varphi(v)\quad uv\in E \implies  \varphi(u)<\varphi(v)$
\end{definition}

\begin{theorem}
    Ациклический ориентированный граф имеет топологическую сортировку.
\end{theorem}
\begin{lemma}
    Если $G$ ациклический граф, то существует вершина, из которой не выходит рёбер.
\end{lemma}
\begin{proof}
    [Доказательство леммы]
    Возьмём вершину: если 

\end{proof}
\begin{proof}
    [Доказательство теоремы]

   $n=1$ дадим единственной вершине номер 1.

   $n>1\quad $ возьмём вершину из которой нет рёбер , дадим ей номер n и удалим её из графа. Граф от этого не стал иметь циклов, поэтому по индукционному предположению мы можем занумеровать оставшиеся $n-1$ элементов.
\end{proof}

Вершины, в которых нет рёбер, называются $x_1, x_2, \ldots, x_{n} $. Дальше идут внутренние вершины, обозначаемые функциями. Например, если обозначена $\land$, то в неё входит два ребра. Если некоммутативная функция, то указывается порядок. Исходящая степень может быть любой. Завершает всё вершина выхода.

\begin{figure}[ht]
    \centering
    \incfig{sceme}
    \caption{sceme}
    \label{fig:sceme}
\end{figure}

$x\oplus y = (x\land \neg y) \lor (\neg x \land y)$

Дерево разбора легко превращается в схему.
\begin{theorem}
    Не существует формулы $len(\phi) = \overset{\sim }O(n)$ для $\oplus_n$ в $\{\land, \lor, \neg\}$.
\end{theorem}
В схеме мы можем пересипользовать то, что в формуле пришлось бы повторять.

$B$ -- базис

 \begin{theorem}
     Функцию $f$ можно задать формулой в базе $B \iff  f$ можно представить схемой 
 \end{theorem}

 \begin{definition}
     Сложностью функции $f$ в базисе $B\quad size_B(f) = \min$ число функциональных элементов в схеме.
 \end{definition}
 \begin{definition}
     Глубина схемы определяется рекурсивно: глубина входов -- 0, глубина вершины -- максимум из глубины входящих + 1

     depth$_B(f)$ -- минимальная глубина схемы для функции.
 \end{definition}

 \begin{theorem}
        $B_1, B_2$ -- базисы.

        $\exists c\quad\forall f\quad size_{B_1}(f) \leqslant c\cdot size_{B_2}(f)$
 \end{theorem}
 \begin{proof}
     $B_2 = \{b_1, b_2, \ldots, b_n\}$

     $b_i$ выразим через $B_1$

     $C\leqslant \max\limits_{b_i\in B_2} size_{B_1}(b_i)$

     (оптимальная схема может быть лучше, поэтому $\leqslant $)
 \end{proof}
 \begin{theorem}
     То же самое про глубину
 \end{theorem}
\begin{corollary}
    $size(f)$ без базиса -- асимптотическое поведение, не зависящее от базиса (по теоремам при переходе к другому базису всё отличается в константу). 
\end{corollary}
\begin{corollary}
    $c_1 size_{B_2}(f) \leqslant size_{B_1}(f) \leqslant  c_2 size_{B_2}(f)$

    Размер функции с точностью до константы не зависит от базиса.
\end{corollary}

\section{Конкретные схемы для логических операций}

Числа хранятся в виде двоичного кода. Занумеруем в двух числах биты: $x_0, \ldots, x_{n}, y_0, \ldots, y_{n} $

Побитовое И -- $n$ элементов  $\land$, принимающие соответствующие разряды.

$z_0 = x_0\land y_0 \ldots z_n = x_{n} \land y_{n} $

Размер схемы: $n\quad $ глубина: 1  $\qquad size=n\quad depth=1$

Побитовое ИЛИ -- так же. Любая побитовая операция -- так же.

Арифметические операции -- не так же. Биты начинают зависеть друг от друга.

Сложение двух битов: заведём два выходных бита:  $low = a\oplus b\quad high = a\land b$. Такая схема называется неполным сумматором. Неполным, потому что из него не собрать сумматор для целых чисел. Для второго бита понадобится сложить биты чисел и ещё бит переноса. Но сумма трёх битов, к счастью, все ещё помещается в два бита $1+1+1=3 = 11_2$

$a,b,c\quad low = \oplus_3\left( a, b, c \right)\quad high = med_3\left( a, b, c \right)  $ -- полный сумматор. Первому биту на перенос подаётся $\mathbb{0}$, а для остальных будут складываться соответствующие биты и перенос с предыдущих битов. Другое название -- линейный сумматор.

$size=n\quad depth = n$

\begin{figure}[ht]
    \centering
    \incfig{sum}
    \caption{sum}
    \label{fig:sum}
\end{figure}

\begin{tabular}{cc|cl}
    0&0& $\mathbb{0}$ &k (kill)\\
    0&1& $x$ & p (propogate)\\
    1&0& x & p\\
    1&1& $\mathbb{1}$ &g (generate)
    
\end{tabular}

\begin{tabular}{c|ccc}
    1$\backslash$ 2&k&g&p\\ \hline
    k&k&g&k\\
    g&k&g&g\\
    p&k&g&p\\
\end{tabular}
$a(bc) = (ab)c = abc$ -- композиция ассоциативна!

Схема композиции: принимает четыре значения, выдаёт два. Имеет константную глубину.

(Дальше жесть, которую я не могу нарисовать, но суть в том, что раз оно ассоциативное, то мы можем запилить двоичное дерево и делать всё за радостный логарифм.)

$size=O(n)\quad depth = O(\log n)$ -- Двоичный каскадный сумматор. Лучше сделать нельзя.

$-y = (\sim y)+1$ отрицательные числа хранятся как дополнение +1

$x-y = x+(~y)+1$. Отрицание  $y$ сделать легко, но как добавить ещё $1$? Но у нас есть нулевой перенос в нулевой разряд. Давайте сделаем его $c_0=1$

\begin{tabular}{ccccccc}
    &&&1&0&1&1\\
    &&&1&1&0&1\\
    \hline
    &&&1&0&1&1\\
    &&0&0&0&0&\\
    &1&0&1&1&&\\
    1&0&1&1&&&\\\hline
\end{tabular}

Умножать двоичные числа в столбик просто. Схема даже имеет название Матричный умножитель.

Дерево Уоллиса: 
Во-первых превратим сумму трёх чисел в сумму двух. Для трёх чисел поразрядно сделаем сумматор, который будет возвращать сумму и перенос побитово. Здесь мы не передаём перенос никуда. Дальше из переносов сделаем число и из сумм сделаем число. Получим два числа и нам нужно сложить уже их.
 \end{document}
